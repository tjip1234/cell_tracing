from pathlib import Path
import xml.etree.ElementTree as ET
import numpy as np
import cv2

class SVGExporter:
    def __init__(self):
        self.scale_factor = 1.0
        
    def export_skeleton_to_svg(self, skeleton, output_path, image_shape=None):
        """Export skeleton as SVG with proper scaling and structure"""
        print(f"SVGExporter: Starting export to {output_path}")
        print(f"SVGExporter: Skeleton shape: {skeleton.shape}, unique values: {np.unique(skeleton)}")
        
        # Get image dimensions
        if image_shape is not None:
            height, width = image_shape[:2]
        else:
            height, width = skeleton.shape
            
        print(f"SVGExporter: Image dimensions: {width}x{height}")
        
        # Create SVG root
        svg = ET.Element("svg")
        svg.set("width", str(width))
        svg.set("height", str(height))
        svg.set("viewBox", f"0 0 {width} {height}")
        svg.set("xmlns", "http://www.w3.org/2000/svg")
        
        # Add metadata
        metadata = ET.SubElement(svg, "metadata")
        metadata.text = "Cell tracing skeleton generated by CellTracing plugin"
        
        # Create main group for skeleton
        skeleton_group = ET.SubElement(svg, "g")
        skeleton_group.set("id", "skeleton")
        skeleton_group.set("stroke", "red")
        skeleton_group.set("stroke-width", "2")
        skeleton_group.set("fill", "none")
        
        # Extract skeleton paths
        paths = self.extract_skeleton_paths(skeleton)
        print(f"SVGExporter: Found {len(paths)} paths")
        
        for i, path in enumerate(paths):
            if len(path) < 2:
                continue
                
            # Create path element
            path_element = ET.SubElement(skeleton_group, "path")
            path_element.set("id", f"segment_{i}")
            
            # Build path data
            path_data = f"M {path[0][0]},{path[0][1]}"
            for point in path[1:]:
                path_data += f" L {point[0]},{point[1]}"
            
            path_element.set("d", path_data)
            print(f"SVGExporter: Added path {i} with {len(path)} points")
            
        # Add endpoints as circles
        endpoints = self.find_endpoints(skeleton)
        print(f"SVGExporter: Found {len(endpoints)} endpoints")
        
        if endpoints:
            endpoints_group = ET.SubElement(svg, "g")
            endpoints_group.set("id", "endpoints")
            endpoints_group.set("fill", "blue")
            
            for i, (x, y) in enumerate(endpoints):
                circle = ET.SubElement(endpoints_group, "circle")
                circle.set("cx", str(x))
                circle.set("cy", str(y))
                circle.set("r", "3")
                circle.set("id", f"endpoint_{i}")
                
        # Write to file
        try:
            tree = ET.ElementTree(svg)
            ET.indent(tree, space="  ", level=0)
            tree.write(output_path, encoding="utf-8", xml_declaration=True)
            print(f"SVGExporter: Successfully wrote SVG to {output_path}")
        except Exception as e:
            print(f"SVGExporter: Error writing file: {str(e)}")
            raise
        
        return output_path
        
    def extract_skeleton_paths(self, skeleton):
        """Extract connected paths from skeleton"""
        print("SVGExporter: Extracting skeleton paths...")
        
        # Ensure skeleton is binary
        binary_skel = (skeleton > 0).astype(np.uint8)
        skeleton_pixels = np.sum(binary_skel)
        print(f"SVGExporter: Binary skeleton has {skeleton_pixels} pixels")
        
        if skeleton_pixels == 0:
            print("SVGExporter: No skeleton pixels found")
            return []
        
        # Find all skeleton pixels
        y_coords, x_coords = np.where(binary_skel > 0)
        print(f"SVGExporter: Found {len(x_coords)} skeleton pixel coordinates")
        
        if len(x_coords) == 0:
            return []
            
        # Simple path extraction - create one path with all points
        # For more sophisticated path extraction, we'd need to trace connected components
        paths = []
        
        # Group nearby points into paths
        visited = set()
        
        for i in range(len(x_coords)):
            point = (x_coords[i], y_coords[i])
            if point not in visited:
                path = self.trace_path_from_point(binary_skel, point, visited)
                if len(path) >= 2:
                    paths.append(path)
                elif len(path) == 1:
                    # Single point - still add it as a small line
                    x, y = path[0]
                    paths.append([(x, y), (x+1, y)])
                    
        print(f"SVGExporter: Extracted {len(paths)} paths")
        return paths
        
    def trace_path_from_point(self, skeleton, start_point, visited):
        """Trace a path from a starting point"""
        path = [start_point]
        visited.add(start_point)
        current = start_point
        
        while True:
            neighbors = self.get_skeleton_neighbors(skeleton, current)
            unvisited_neighbors = [n for n in neighbors if n not in visited]
            
            if len(unvisited_neighbors) == 0:
                break
            elif len(unvisited_neighbors) == 1:
                current = unvisited_neighbors[0]
                visited.add(current)
                path.append(current)
            else:
                # Multiple neighbors - pick one and stop
                current = unvisited_neighbors[0]
                visited.add(current)
                path.append(current)
                break
                
        return path
        
    def get_skeleton_neighbors(self, skeleton, point):
        """Get neighboring skeleton pixels"""
        x, y = point
        neighbors = []
        
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if (0 <= ny < skeleton.shape[0] and 0 <= nx < skeleton.shape[1] and 
                    skeleton[ny, nx] > 0):
                    neighbors.append((nx, ny))
                    
        return neighbors
        
    def find_endpoints(self, skeleton):
        """Find skeleton endpoints"""
        print("SVGExporter: Finding endpoints...")
        
        binary_skel = (skeleton > 0).astype(np.uint8)
        
        if np.sum(binary_skel) == 0:
            return []
        
        # Create kernel to count neighbors
        kernel = np.array([[1, 1, 1],
                          [1, 0, 1],
                          [1, 1, 1]], dtype=np.uint8)
        
        # Count neighbors for each skeleton pixel
        neighbor_count = cv2.filter2D(binary_skel, -1, kernel)
        
        # Endpoints have exactly one neighbor
        endpoints = (binary_skel == 1) & (neighbor_count == 1)
        y_coords, x_coords = np.where(endpoints)
        
        result = list(zip(x_coords, y_coords))
        print(f"SVGExporter: Found {len(result)} endpoints")
        return result